# 1. var, let, const 비교 (중복 선언 허용, 스코프, 호이스팅)

| 특성                 | var                   | let             | const           |
| ------------------ | --------------------- | --------------- | --------------- |
| 중복 선언 허용           | O                     | X               | X               |
| 스코프(Scope)<br>     | 함수 스코프                | 블록 스코프          | 블록 스코프          |
| 호이스팅(Hoisting)<br> | 선언+초기화<br>(undefined) | 선언만 <br>(초기화 X) | 선언만 <br>(초기화 X) |
| 재할당 가능 여부          | O                     | O               | X               |

### 중복 선언 허용
- var은 동일한 변수명을 여러 번 선언할 수 있지만, **let과 const는 중복 선언이 불가능**하다.
```js
var a = 1;
var a = 2; // 가능

let b = 1;
let b = 2; // 에러 발생 (SyntaxError)

const c = 1;
const c = 2; // 에러 발생 (SyntaxError)
```

### 스코프(Scope)
- var은 함수 스코프를 가지며, 함수 안에서 선언되면 외부에서 접근할 수 없다.
- let과 const는 블록 스코프를 가지며, {} 안에서만 유효하다.
```js
function test() {
    if (true) {
        var x = 10;
        let y = 20;
    }
    console.log(x); // 10 (함수 스코프)
    console.log(y); // 에러 (블록 스코프)
}
```

### 호이스팅(Hoisting)
- var은 선언과 동시에 undefined로 초기화됩니다.
- let과 const는 선언만 되고 초기화되지 않아서 접근하면 에러가 발생합니다.
```js
console.log(a); // undefined
var a = 10;

console.log(b); // 에러 (Cannot access 'b' before initialization)
let b = 20;
```

# 2. 브라우저는 어떻게 동작하는가

## (0) 브라우저란

브라우저란, 웹 페이지, 이미지, 비디오 등의 콘텐츠를 수신, 전송 및 표현하는 소프트웨어입니다. 
(인터넷에 접속하기 위해 사용하는 Chrome, Safari, Edge, Firefox 등)

## (1) 브라우저의 구조
- **사용자 인터페이스** (UI): 주소창, 뒤로 가기, 새로고침 등의 요소
	- 주소 표시줄, 각종 버튼(이전/다음, 새로고침, 설정, 닫기 등), 북마크 메뉴 등. 
	- 요청한 페이지를 보여주는 영역을 제외한 나머지 모든 부분이 사용자 인터페이스에 해당합니다.
- 브라우저 엔진:
	- 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어해주는 엔진입니다. 
	- 자료 저장소를 참조하며 로컬에 데이터를 읽기/쓰기 하면서 다양한 작업을 합니다.
- **렌더링 엔진**: HTML, CSS를 화면에 표시하는 역할 (ex. 크롬의 Blink)
	- 요청한 콘텐츠를 표시합니다. 
	- 요청한 웹 페이지의 HTML과 CSS를 파싱하여 화면에 표시합니다.
- **자바스크립트 엔진**: 자바스크립트 실행 (ex. Chrome V8)
- **네트워크 모듈**: HTTP 요청 및 응답 처리
	- HTTP 요청과 같은 네트워크 호출에 사용됩니다.
- **데이터 저장소**: 쿠키, 로컬스토리지, 세션스토리지 등
	- 쿠키, 로컬 스토리지와 같이 로컬 영역에 저장해야 하는 모든 종류의 데이터들을 저장합니다.
- 자바스크립트 해석기: 
	- 자바스크립트 코드를 해석하고 실행합니다.
- UI 백엔드: 
	- input, select 와 같이 기본적으로 지원하는 요소를 그립니다.
	- OS 사용자 인터페이스에서 정해준 것들을 사용합니다.

## (2) 브라우저의 동작 과정

### 1) 통신 과정
1. URL 입력 → 사용자가 주소창에 https://example.com 입력
2. DNS 조회 → example.com의 실제 IP 주소를 찾음
3. 서버 요청 → IP 주소로 해당 웹사이트의 HTML을 요청 (HTTP GET request)
	- TCP 핸드쉐이크를 통해 연결을 설정. (보안성 있는 연결을 위해서는 TLS 협상도 필요)
4. 응답 받기 → 서버가 HTML, CSS, JavaScript 등을 응답으로 보냄

### 2) 렌더링 과정

1. **DOM**, **CSSOM** 생성
	- DOM: Document Object Model
	- CSSOM: CSS Object Model
	- 서버로부터 받은 HTML, CSS를 Parser를 통해 텍스트에서 Object Model로 만든다. (HTML→ DOM Tree, CSS→ CSSOM)
2. **Render Tree** 생성
	- Render Tree에는 스타일 정보가 설정되어 있음
	- 실제 화면에 표현되는 노드들로 구성
3. **Layout**
	- Render Tree 노드들이 가지고 있는 스타일과 속성에 따라서 브라우저 화면의 어느 위치에 어떤 크기로 출력할지 계산하는 과정
4. **Paint**
	- Layout 계산에 따라 요소들을 실제 화면에 그리는 과정 
	- 이전 단계에서 요소들의 위치와 크기, 스타일 계산이 완료된 Render Tree를 이용해 실제 값을 채워 넣습니다. 이 때 텍스트, 색, 이미지, 그림자 효과 등을 모두 처리해 그립니다.

# 3. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임

## 이벤트 버블링
- 자식 요소에서 부모 요소로 이벤트가 전파되는 것
- 이를 막으려면 이벤트 객체에서 `stopPropagation` 메소드로 전파를 막을 수 있다.

## 이벤트 캡쳐링
- 부모 요소에서 자식 요소로 이벤트가 전파되는 것
- 캡쳐링 단계에서 이벤트 핸들러를 동작시키려면, `addEventListener` 에 세번째 프로퍼티에 `true` 또는 `{ capture: true }` 를 전달하면 된다.

## 이벤트 위임
- 자식 요소 각각에 이벤트 핸들러를 하나씩 등록할 필요 없이 부모 요소에서 한 번에 자식 요소들에 발생한 이벤트를 관리하는 방식

# 정리
- var, let, const → 선언 방식의 차이 (스코프, 중복 선언, 호이스팅)
- 브라우저 동작 원리 → HTML → CSS → JS → 렌더링 과정
	- 렌더링: HTML 파싱 → DOM 생성
	- CSS 파싱 → 스타일을 적용하여 렌더 트리(Render Tree) 생성
	- 자바스크립트 실행 → 페이지 동적 조작
	- 레이아웃 계산 & 페인트(Paint) → 최종 화면 출력
- 이벤트 전파
	- 이벤트 전파 흐름: 캡처링 → 타깃 → 버블링
	- 이벤트 버블링: 자식 → 부모, `e.stopPropagation()`로 방지
	- 이벤트 캡처링: 부모 → 자식
	- 이벤트 위임: 부모 → 자식 요소 발생 이벤트 관리

