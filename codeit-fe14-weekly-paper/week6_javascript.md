
# 1. HTTP 메소드

HTTP 메소드란, 클라이언트가 웹 서버에게 사용자 리퀘스트의 목적이나 종류 등을 알리는 수단

- **GET**: 데이터를 받기 위해 사용하는 메소드
	- 리퀘스트 바디 X, 쿼리 스트링 O
	- 리퀘스트 캐시 O (불필요한 리퀘스트를 제한하기 위함)
	- 서버의 데이터 변경 X
	- 멱등성 O (동일한 리퀘스트를 반복하여 전송하더라도 동일한 응답이 돌아온다.)
- **POST**: 새로운 리소스를 생성하거나 기존 리소스를 수정하기 위해 서버에 데이터를 보내는 메소드
	- 리퀘스트 바디 O
	- 리퀘스트 캐시 X (일반적으로 캐시되지 않는다)
	- 서버의 데이터 생성 or 변경 O
	- 멱등성 X (동일한 리퀘스트를 반복하더라도 동일한 응답을 보장할 수 없다. 리소스 생성할 경우, 이미 리소스가 있더라도 새로운 리소스를 생성하기 때문.)
- **PUT**: 새로운 리소스를 생성하거나 기존 리소스를 수정하기 위해 서버에 데이터를 보내는 메소드
	- 서버의 데이터 생성 or 변경 O (서버에 리소스가 없으면 생성하고, 있으면 클라이언트가 보낸 데이터로 대체하고 추가로 생성하진 않는다.)
	- 멱등성 O
- **DELETE**: 지정한 리소스를 삭제하는 메소드입니다.
	- 서버의 데이터 삭제
	- 멱등성 O

- PATCH: 기존 리소스의 부분적인 수정을 위한 메소드
	- PUT 리퀘스트는 데이터를 완전히 대체하는 반면, PATCH는 부분 수정을 위한 메소드다.
	- 예시: id, name, email, password 전체를 생성 또는 변경하는데는 PUT을 사용하고, 기존에 있던 데이터에 name만 변경할 때는 PATCH를 사용
		```js
		{
		    id: 'codeit',
		    name: '코드잇',
		    email: 'codeit@codeit.com',
		    password: '1234'
		}
		```
	- 멱등성 X
- HEAD: 특정 리소스를 GET 메소드로 요청했을 때 돌아올 헤더를 받기 위한 메소드. 
	- 실제 데이터가 아니라 데이터에 관한 정보만 얻으려고 하는 상황에 활용한다.
	- 리스폰스 바디 X, 헤드 부분만 받는다.
	- 리퀘스트가 캐시 O (불필요한 리퀘스트를 제한하기 위해)
	- 멱등성 O
- OPTIONS: 주어진 URL 또는 서버에 대해 허용된 통신 옵션을 받기 위한 메소드
	- 허용된 리퀘스트 메소드를 확인하거나 리소스에 대해 지원하는 옵션을 확인할 때 사용한다.
	- 멱등성 O
- CONNECT: 요청한 리소스에 대해 양방향 연결을 시작하는 메소드
	- SSL을 사용하는 웹사이트(HTTPS)에 접속하는데 사용될 수 있다.
 
# 2. 자바스크립트의 특징

자바스크립트는 싱글 스레드 기반의 언어다. (스레드란, 작은 단위의 실행 흐름을 말한다.)

자바스크립트는 코드 순서대로 진행되지 않는다. **비동기 처리**(Asynchronous Execution)를 지원하기 때문이다.
- 브라우저는 JavaScript를 실행할 때 싱글 스레드(Single Thread) 방식으로 동작하지만, Web API와 이벤트 루프(Event Loop)를 활용해 비동기 작업을 처리할 수 있음.
- 비동기 작업 예시: AJAX 요청, 타이머(setTimeout), 이벤트 리스너

## 동기(Synchronous)와 비동기(Asynchronous)

1. 동기 코드: 순서대로 실행되며, 이전 코드가 끝나야 다음 코드가 실행됨.

	```js
	console.log("A");
	console.log("B");
	console.log("C");
	// 출력: A B C
	```

2. 비동기 코드: 특정 코드가 실행될 때, 결과를 기다리지 않고 다음 코드를 실행함.

	```js
	console.log("A");
	setTimeout(() => console.log("B"), 1000);
	console.log("C");
	// 출력: A C (1초 후) B
	```

### 자바스크립트의 엔진 구성

- Memory Heap
- Call Stack
	- 하나의 스레드에서 하나의 Call Stack으로 함수의 동작 순서 등을 제어한다

### 런타임 환경

자바스크립트 엔진은 단일 Call Stack으로 요청이 들어온 순서대로 한 가지 일만을 수행하며, **비동기 요청**은 자바스크립트 엔진을 구동하는 **런타임 환경**에서 담당한다.
- 예시 1) 브라우저에서 setTimeout 구동
	1. Call Stack에서 Web API setTimeout 요청 이후 제거됨
	2. Web API에서 setTimeout이 완료되면, setTimeout callback 함수를 Callback Queue로 옮김
	3. 현재 실행한 자바스크립트 코드를 모두 실행한 뒤, Event Loop가 지속적으로 Call Stack이 비어있는지 확인
	4. Call Stack이 비어있다면 Callback Queue에 있는 작업 순서대로 Call Stack으로 넘겨 실행
- 예시 2)
	```js
	// 1번
	let num = 1;
		
	// 2번
	setTimeout(() => {
	  num = 2;
	}, 0);
	
	// 3번
	num = 3;
	
	// 4번
	console.log(num); // 3
	```
	- 1번 실행으로 `num` 에 1이 할당된다.
	- 2번 실행으로 `setTimeout` 을 Web API(NodeJS의 경우 Timers 모듈)가 처리하도록 넘긴다. (callback 실행 X)
	- 2번 실행 완료되면, 즉 `setTimeout` 작업이 완료되면 Web API에서는 `setTimeout` callback 함수를 Callback Queue에 등록한다.
	- 3번 실행으로 `num` 에 3이 재할당된다.
	- 4번 실행으로 화면에 3이 출력된다.
	- 4번까지 모든 실행이 완료된 후, Event Loop가 돌아 callback 함수가 Callback Queue → Call Stack 이동 및 실행되어, `num` 은 2가 재할당된다.

## 정리
- 자바스크립트는 싱글스레드 언어
- 비동기 요청은 자바스크립트 엔진을 구동하는 런타임 환경에서 제어
- 즉, 비동기 처리 → 이벤트 루프와 콜백 함수로 실행 순서 제어

# 3. AJAX

## AJAX (Asynchronous JavaScript And XML)

- 설명: 페이지를 새로고침하지 않고 서버와 데이터를 주고받는 기술입니다.
- 특징:
	- 비동기(Asynchronous) 방식으로 동작 → 페이지가 깜빡이지 않고 업데이트 가능
	- 백그라운드에서 서버와 통신 → 사용자 경험(UX) 향상
	- JSON, XML 등의 데이터를 서버에서 받아와 웹페이지에 적용 가능
- 사용 예시:
	```js
	fetch("https://jsonplaceholder.typicode.com/posts/1")
	   .then(response => response.json()) // JSON으로 변환
	   .then(data => console.log(data)) // 데이터 출력
	   .catch(error => console.error("Error:", error));
	```
- 사용 사례:
	- 검색 자동완성 기능
	- 실시간 채팅
	- 무한 스크롤 (Infinite Scroll)

## AJAX 등장 배경

초창기의 웹은 일부분만 바뀌면 되는 경우에도 매번 새 페이지가 로드되는 방식이어서 효율적이지 않고 사용자에게도 좋지 않은 경험을 줬다. 그래서 2000년대 초부터는 웹의 이런 단점을 극복하기 위해서 AJAX라는 기술이 도입되었다.

## AJAX 의미

AJAX는 **A**synchronous **J**avaScript **A**nd **X**ML의 줄임말이다. 이는 자바스크립트를 사용해서 **비동기**적으로 리퀘스트를 보내고 리스폰스를 받는데 기반이 되는 **기술들의 집합**을 의미한다. 즉, AJAX는 웹 브라우저가 현재 페이지를 그대로 유지한 채로 서버에 리퀘스트를 보내고 리스폰스를 받아서, 새로운 페이지를 로드하지 않고도 페이지에 변화를 줄 수 있게 해주는 기술이다.

여기서 XML은 AJAX라는 용어가 생겨난 당시에 가장 많은 인기를 누리던 데이터 타입을 뜻한다. 요즘은 더 가벼운 용량과 JavaScript의 일부라는 장점 때문에 JSON을 많이 사용한다. (JSON과 XML 모두 AJAX에서 정보를 담을 때 사용)

## AJAX의 활용

- 서버와 통신하기 위해 보내는 **HTTP 리퀘스트**가 AJAX 기술의 핵심이라고 할 수 있는, 이를 위해서는 기능을 제공하는 객체의 인스턴스가 필요했고, `XMLHttpRequest` 가 대표적으로 사용된 객체이다.
- 요즘은 Fetch API나 `XMLHttpRequest` 를 기반으로 더 쓰기 편하게 만들어진 **axios**와 같은 패키지를 사용해서 AJAX를 활용하고 있다.

## 정리
- AJAX → 새로고침 없이 서버와 통신 가능

# 4. 실행 컨텍스트

## 실행 컨텍스트(Execution context)

실행 컨텍스트는 **실행 가능한 코드를 형상화하고 구분하는 추상적인 개념**이다. 즉, **실행 가능한 소스 코드를 해석**하고, **실행하기 위해 필요한 환경을 제공**하며, **코드의 실행 결과를 실제로 관리**하는 환경을 말한다.

## 실행 컨텍스트의 종류

- **전역 실행 컨텍스트** (Global Execution Context) : 어떤 함수에도 포함되지 않는 코드는 전역 실행 컨텍스트에 속하며, 자바스크립트 기본이 되는 컨텍스트다. 자바스크립트 프로그램에 하나의 전역 실행 컨텍스트만 있다.
- **함수 실행 컨텍스트** (Functional Execution Context) : 함수가 호출될 때마다 해당 함수를 위한 새로운 실행 컨텍스트가 생성된다.
- **`eval` 함수 실행 컨텍스트** (Eval Execution Context) : `eval` 함수내에서 실행된 코드들도 자체 실행 컨텍스트를 가진다.

## 실행 컨텍스트 스택 (=실행 스택, **≈**콜 스택)

자바스크립트에서 실행 컨텍스트를 추적하기 위해서 실행 컨텍스트 스택을 사용한다. 
- 실행 컨텍스트 스택: 
	- 실행 중에 생성된 모든 컨텍스트들을 저장
	- Last In, First Out의 스택 자료구조

자바스크립트 엔진이 스크립트를 처음으로 마주하게 되면 전역 실행 컨텍스트를 생성하여 스택에 푸쉬한다. 이후 자바스크립트 엔진이 함수 호출을 발견할 때마다 해당 함수에 대한 실행 컨텍스트를 생성하여 스택의 상단에 푸쉬한다.

스택의 최상단에 있는 실행 컨텍스트의 함수를 실행하고, 함수 실행을 완료하면 스택에서 제거하고 현재 컨텍스트의 아래에 있는 컨텍스트로 컨트롤이 이동한다.

## 참고

모던 자바스크립트 Deep Dive:  [23.4. 실행 컨텍스트 스택](../javascript-deep-dive/23_execution_context.md#234-실행-컨텍스트-스택)

# 4. 클로저

## 클로저란

클로저(Closure)는 JavaScript 고유 개념이 아니라 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
- “클로저는 **함수**(내부함수)와 **그 함수가 선언됐을 때의 렉시컬 환경**과의 조합” (MDN에 정의된 내용)
	- 함수란, 외부함수와 내부함수가 있을 때 "내부함수"를 의미
	- 그 함수가 선언될 때의 렉시컬 환경이란, 내부함수가 선언됐을 때의 스코프 범위 안에 있는 변수와 함수를 저장하는 객체를 의미

즉, 클로저는 반환된 내부함수가 **자신이 선언됐을 때의 환경인 스코프를 기억**하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다.

```js
function outerFunc() {
  const x = 7;
  const innerFunc = function () { console.log(x); };
  return innerFunc;
}

/**
 *  함수 outerFunc를 호출하면 내부 함수 innerFunc 반환
 *  그리고 함수 outerFunc의 실행 컨텍스트는 소멸
 */
var inner = outerFunc();
inner(); // 7
```

함수 `outerFunc`는 내부함수 `innerFunc`을 반환하고 life-cycle은 종료된다. 하지만 외부함수 실행 컨텍스트 내의 변수는 내부함수에 의해 참조되는 한 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있다.

즉 외부함수를 이미 반환했더라도 외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다.

클로저는 자신이 생성될 때의 환경을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있지만, 필요에 따라 유용하게 사용하면 좋다.

## 클로저의 활용

- 현재 상태를 기억하고 변경된 최신 상태를 유지
    - 참고: [https://poiemaweb.com/js-closure#21-상태-유지](https://poiemaweb.com/js-closure#21-%EC%83%81%ED%83%9C-%EC%9C%A0%EC%A7%80)
- **정보의 은닉**
    - 참고: [https://poiemaweb.com/js-closure#23-정보의-은닉](https://poiemaweb.com/js-closure#23-%EC%A0%95%EB%B3%B4%EC%9D%98-%EC%9D%80%EB%8B%89)
- **고차 함수**
    - 참고: https://poiemaweb.com/js-array-higher-order-function

## 참고 자료

- https://poiemaweb.com/js-closure
- https://ko.javascript.info/closure
- 모던 자바스크립트 Deep Dive: [24. 클로저](../javascript-deep-dive/24_closure.md)