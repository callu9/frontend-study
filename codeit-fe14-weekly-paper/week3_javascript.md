# 1. `==`와 `===`의 차이

자바스크립트에서 `==`와 `===`는 비교 연산자로, 두 값을 비교할 때 사용되지만, 비교 방식에서 큰 차이가 있다.

## `==` (동등 연산자)
- 설명: 두 값을 비교할 때, 타입을 자동으로 변환(type coercion) 한 후 값을 비교합니다.
- 특징:
	- 타입이 다르면, 자바스크립트가 자동으로 타입을 일치시킨 후 비교합니다.
	- 타입 변환으로 인해 예상치 못한 결과가 나올 수 있습니다.
- 예시:
	```js
	console.log(1 == '1');   // true (숫자와 문자열을 같은 값으로 간주)
	console.log(true == 1);  // true (불리언을 숫자로 변환)
	console.log(null == undefined); // true (특별 케이스)
	```

## `===` (일치 연산자)
- 설명: 두 값을 비교할 때, 타입까지 엄격하게 비교합니다.
- 특징:
	- 타입 변환이 일어나지 않습니다.
	- 값 뿐만 아니라 타입까지 일치해야 true를 반환합니다.
- 예시:
	```js
	console.log(1 === '1');   // false (타입이 다름)
	console.log(true === 1);  // false (타입이 다름)
	console.log(null === undefined); // false (타입이 다름)
	```

## 차이 요약

| 연산자   | 타입 변환     | 비교 조건                         | 비유             |
| ----- | --------- | ----------------------------- | -------------- |
| `==`  | O<br><br> | 값만 같으면 true<br>(느슨한 비교)       | “둘이 비슷하면 OK!”  |
| `===` | X         | 값과 타입 모두 같아야 true<br>(엄격한 비교) | “완전히 똑같아야 OK!” |

## 관련 내용
- `==` 는 암묵적 형변환이이 일어나는데, 암묵적 형변환이 일어날 것을 모두 기억하거나 예측하는 것이 어렵기 때문에, 의도하지 않은 결과를 얻게 될 가능성이 크고 이로 인해 오류 가능성이 커집니다. 따라서 동등함을 비교하기 위해서 `===` 를 사용하는 것이 좋습니다.
- 비교 연산 중에 ES6(ECMAScript 2015)에 추가된 Object.is 도 있습니다. +0, 0, NaN, 비교 이외에는 `===` 연산과 동일한 결과를 줍니다.
- 객체간 비교할 경우 객체 안의 내용이 같더라도 참조형이기 때문에 `==`, `===`, `Object.is` 로 비교하면 false로 판단합니다. 따라서 `JSON.stringify` 로 객체 안의 내용을 문자열로 변환한 후 비교 하거나 순서가 보장되지 않는 값이라면, 정렬 후 비교 합니다.

### 참고
https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness

# 2. 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)

## 자바스크립트 자료형

자바스크립트에서 값을 복사할 때, 자료형에 따라 복사하는 값이 달라집니다.

- 기본형(Primitive type): Number, String, Boolean, Null, Undefined, Symbol
	- 데이터 변경이 불가(immutable)합니다. 
	- 변수에 기본형을 할당하면 새로운 메모리 공간에 독립적인 **실제값이 복사**됩니다.
	```js
	let x = 1;
	let y = x;
	
	x = 123
	
	console.log(x) // 123을 출력
	console.log(y) // 1을 출력 (y에 할당되었던 1이 변경되지 않음)
	```
- 참조형(Reference type): Object(Array, Function, Map 등 기본형을 제외한 모든 것)
	- 데이터의 내용 변경이 가능(mutable)합니다. 
	- 변수에 참조형을 할당하면 해당 **객체의 메모리 주소값이 복사**됩니다.
	```js
	let obj1 = {num: 1};
	let obj2 = obj1;
	
	obj1.num = 123
	
	console.log(obj1) // {num: 123}을 출력
	console.log(obj2) // {num: 123}을 출력 (obj2에 할당되었던 {num: 1}의 내용이 obj1을 따라 변경)
	
	// obj2 가 obj1 객체의 메모리 주소값을 복사하기 때문에, 
	// obj1 의 값이 변경되면 obj2 도 동일한 메모리 주소에 있는 값을 가져 변경된 값을 갖게 됩니다.
	```

따라서, 얕은 복사와 깊은 복사는 객체 또는 배열을 복사할 때, 데이터 구조와 메모리의 다루는 방식에서 차이가 있다.

## 얕은 복사 (Shallow Copy)
- 설명: 
	- 원본 객체의 1단계 속성만 복사합니다.
	- 복사된 객체는 원본 객체와 참조 주소를 공유합니다. 즉, 중첩된 객체나 배열의 내용은 복사되지 않고, 같은 메모리를 가리킵니다.
 - 특징:
	- 원본 객체가 변경되면, 복사본도 영향을 받을 수 있습니다.
	- 성능이 빠르고 간단한 구조에서는 유용합니다.
- 예시:
	```js
	const original = { name: "Alice", details: { age: 25 } };
	const shallowCopy = { ...original }; // 얕은 복사
	
	shallowCopy.details.age = 30;
	console.log(original.details.age); // 30 (원본도 변경됨)
	```


## 깊은 복사 (Deep Copy)
- 설명: 
	- 원본 객체의 모든 데이터를 재귀적으로 복사합니다.
	- 복사된 객체는 원본 객체와 완전히 독립적이며, 중첩된 객체나 배열까지 새롭게 복사됩니다.
- 특징:
	- 원본 객체가 변경되어도, 복사본에는 영향을 주지 않습니다.
	- 복사가 복잡하고 성능이 상대적으로 느립니다.
- 예시:
	```js
	const original = { name: "Alice", details: { age: 25 } };
	
	const deepCopy = JSON.parse(JSON.stringify(original)); // 깊은 복사
	deepCopy.details.age = 30;
	
	console.log(original.details.age); // 25 (원본은 영향받지 않음)
	```


## 비교
| 비교 항목                    | 복사 범위           | 참조 관계              | 성능  | 사용 예       | 비유                                      |
| ------------------------ | --------------- | ------------------ | --- | ---------- | --------------------------------------- |
| 얕은 복사 <br>(Shallow Copy) | 1단계 속성만 복사      | 중첩된 객체는 원본과 참조를 공유 | 빠름  | 간단한 객체     | “겉모습만 복사하는 것.” <br>(옷만 다른데 속은 같음)       |
| 깊은 복사 <br>(Deep Copy)    | 중첩된 데이터까지 모두 복사 | 모든 데이터가 완전히 독립적    | 느림  | 중첩된 객체나 배열 | “완전히 새로운 사람을 만드는 것.” <br>(겉과 속이 모두 독립적) |

## 참조형의 깊은 복사

- `JSON.parse(JSON.stringify(obj))`, `JSON.stringify()`
	- 객체를 json 문자열로 변환하는데 이 과정에서 원본 객체와의 참조가 모두 끊어지고, 객체를 json 문자열로 변환 후, JSON.parse() 를 이용해 다시 원래 객체로 만들어 줍니다.
	- 가장 간편하다는 장점이 있습니다.
	- function이 있는 경우 undefined 처리한다는 단점이 있습니다.
	- 다른 방법에 비해 느리다는 단점이 있습니다.
- 커스텀 재귀 함수를 활용한 복사
	- 객체의 함수도 제대로 표현할 수 있습니다.
	- 복잡하다는 단점이 있습니다.
- Lodash와 같은 외부 라이브러리 활용
	- 외부 라이브러리 사용에 제약이 없다면 가장 효과적인 선택지가 될 수 있습니다.

### 참고
https://choar816.tistory.com/154

### 추가 설명

- 얕은 복사 방법:
	- `Object.assign()`
	- Spread 연산자 `{ ...obj }`
- 깊은 복사 방법:
	- `JSON.parse(JSON.stringify(obj))` (단, 함수나 undefined는 복사되지 않음)
	- 외부 라이브러리 활용 (ex. Lodash의 cloneDeep)

