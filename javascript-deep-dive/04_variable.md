# 4. 변수

## 4.1. 변수란?

### 변수 (variable)

- 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 프로그래밍 언어에서 값을 저장하고 참고하는 메커니즘으로, **값의 위치를 가리키는 상징적인 이름**
- 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

```js
//  변수명    변수 값
var result = 10 + 20;
```

### 할당 (assignment)

변수에 값을 저장하는 것

### 참조 (reference)

변수에 저장된 값을 읽어 들이는 것


## 4.2. 식별자

### 식별자 (identifier)

- 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름, 즉 **메모리 주소**에 붙인 이름으로, 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.
- 메모리 상 존재하는 어떤 값(변수, 함수, 클래스 등)을 식별할 수 있는 이름은 모두 식별자라고 한다.
- 식별자는 네이밍 규칙을 준수해야 하며, 선언(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

## 4.3. 변수 선언

- 변수 선언(variable declaration)이란 변수를 생성하는 것을 말한다.
- 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)하여 값을 저장할 수 있게 준비
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전 까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호된다.
- 변수를 사용하려면 반드시 선언이 필요하며, 선언 시 `var`, `let`, `const` 키워드를 사용한다.

### ES5 vs. ES6

- ES5까지는 `var` 키워드가 유일한 변수 선언 키워드, ES6에서 `let`, `const` 도입
- var 키워드의 단점: 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원
- ES6는 ES5의 상위 집합(superset)으로, 권장하지는 않지만 var 키워드를 사용할 수 있으며, ES6 이전 사양으로 구현된 코드더라도 ES6 기반의 자바스크립트 엔진에서 모두 정상적으로 동작한다.

### 변수 선언 과정

1) 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2) 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

- 변수 이름을 비롯한 모든 식별자는 key/value 형식인 객체로 실행 컨텍스트에 등록되어 관리된다.<br />(자바스크립트 엔진이 변수를 관리하는 매커니즘은 [13. 스코프](./13_scope.md), [23. 실행 컨텍스트](./23_execution_context.md) 참고)

- `var` 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. 
- 만약 선언하지 않은 식별자에 접근하면 `ReferenceError`(참조 에러) 발생

## 4.4. 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score); // undefined

var score; // 변수 선언문
```

### `ReferenceError`(참조 에러)가 발생하지 않는 이유

변수선언이 소스코드가 한줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문.

자바스크립트 엔진은 실행에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이때 변수 선언문, 함수 선언문 등 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. 소스코드의 평가 과정이 끝나면 비로소 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

### 호이스팅 (hoisting)
- 변수, 함수, 클래스의 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징.
- `var`, `let`, `const`, `funtion`, `funtion*`, `class` 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)은 호이스팅 된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

## 4.5. 값의 할당

### 할당 (assignment)

할당 연산자 `=`를 사용하여 우변의 값을 좌변의 변수에 할당한다.
자바스크립트 엔진은 변수 선언과 값의 할당 2개의 문으로 나누어 각각 실행한다.

```js
var score = 80; // 변수 선언과 값의 할당
                //    ↓
var score;      // 변수 선언
score = 80;     // 값의 할당
```

변수 선언과 값의 할당 실행 시점이 다르다.
- 변수 선언: 런타임(소스코드가 순차적으로 실행되는 시점) 이전에 먼저 실행
- 값의 할당: 런타임에 실행. 
  - 주의. undefined가 저장되어 있던 이전의 메모리 공간을 지우는 것이 아니라 새로운 메모리 공간을 확보하여 값을 저장한다.

```js
console.log(score); // undefined

var score;  // ① 변수 선언
score = 80; // ② 값의 할당

console.log(score); // 80
```

## 4.6. 값의 재할당

- 재할당: 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

```js
var score = 80; // 변수 선언과 값의 할당
score = 90;     // 값의 재할당
```

- 참고: 값을 재할당할 수 없어서 값을 변경할 수 없다면, 변수가 아니라 상수(constant). 상수는 한번 정해지면 변하지 않는 값이며, 즉 단 한 번만 할당할 수 있는 변수다.
- 주의: 재할당 시 이전의 메모리 공간을 지우는 것이 아니라 새로운 메모리 공간을 확보하여 값을 저장하며, 이전 값은 불필요하여 가비지 콜렉터에 의해 메모리에서 자동 해제되나, 메모리에서 언제 해제될지는 예측할 수 없다.

### 가비지 콜렉터 (garbage collector)

애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는(어떤 식별자도 참조하지 않는) 메모리를 해제(release)하는 기능을 말한다.<br />
자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수(memory leak) 방지한다.

## 4.7. 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)를 포함할 수 있다.
- 단, 식별자는 숫자로 시작하는 것은 허용하지 않으며, 특수문자를 제외한 문자, 언더스코어(`_`), 달러 기호(`$`)로 시작해야 한다.
- 예약어는 식별자로 사용할 수 없다.

### 예약어 (reserved word)

프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어. (await, break, case, catch, class, const, continue, debugger, default, delete, do, else, enum, export, extends, false, finally, for, function, if...)

### 네이밍 컨벤션 (naming convention)

```js
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

일반적인 사용 범위
- 카멜 케이스: 변수, 함수
- 파스칼 케이스: 생성자 함수, 클래스명